{"ast":null,"code":"import * as types from '../constants/action_types';\nimport utils from '../utils';\nconst request = new XMLHttpRequest();\n\nfunction originPoint(coordinates) {\n  return dispatch => {\n    const origin = utils.createPoint(coordinates, {\n      id: 'origin',\n      'marker-symbol': 'A'\n    });\n    dispatch({\n      type: types.ORIGIN,\n      origin\n    });\n    dispatch(eventEmit('origin', {\n      feature: origin\n    }));\n  };\n}\n\nfunction destinationPoint(coordinates) {\n  return dispatch => {\n    const destination = utils.createPoint(coordinates, {\n      id: 'destination',\n      'marker-symbol': 'B'\n    });\n    dispatch({\n      type: types.DESTINATION,\n      destination\n    });\n    dispatch(eventEmit('destination', {\n      feature: destination\n    }));\n  };\n}\n\nfunction setDirections(directions) {\n  return dispatch => {\n    dispatch({\n      type: types.DIRECTIONS,\n      directions\n    });\n    dispatch(eventEmit('route', {\n      route: directions\n    }));\n  };\n}\n\nfunction updateWaypoints(waypoints) {\n  return {\n    type: types.WAYPOINTS,\n    waypoints: waypoints\n  };\n}\n\nfunction setHoverMarker(feature) {\n  return {\n    type: types.HOVER_MARKER,\n    hoverMarker: feature\n  };\n}\n\nfunction fetchDirections() {\n  return (dispatch, getState) => {\n    const {\n      api,\n      accessToken,\n      routeIndex,\n      profile,\n      alternatives,\n      congestion,\n      destination,\n      language,\n      exclude\n    } = getState(); // if there is no destination set, do not make request because it will fail\n\n    if (!(destination && destination.geometry)) return;\n    const query = buildDirectionsQuery(getState); // Request params\n\n    var options = [];\n    options.push('geometries=polyline');\n    if (alternatives) options.push('alternatives=true');\n    if (congestion) options.push('annotations=congestion');\n    options.push('steps=true');\n    options.push('overview=full');\n    if (language) options.push('language=' + language);\n    if (exclude) options.push('exclude=' + exclude);\n    if (accessToken) options.push('access_token=' + accessToken);\n    request.abort();\n    request.open('GET', \"\".concat(api).concat(profile, \"/\").concat(query, \".json?\").concat(options.join('&')), true);\n\n    request.onload = () => {\n      if (request.status >= 200 && request.status < 400) {\n        var data = JSON.parse(request.responseText);\n\n        if (data.error) {\n          dispatch(setDirections([]));\n          return dispatch(setError(data.error));\n        }\n\n        dispatch(setError(null));\n        if (!data.routes[routeIndex]) dispatch(setRouteIndex(0));\n        dispatch(setDirections(data.routes)); // Revise origin / destination points\n\n        dispatch(originPoint(data.waypoints[0].location));\n        dispatch(destinationPoint(data.waypoints[data.waypoints.length - 1].location));\n      } else {\n        dispatch(setDirections([]));\n        return dispatch(setError(JSON.parse(request.responseText).message));\n      }\n    };\n\n    request.onerror = () => {\n      dispatch(setDirections([]));\n      return dispatch(setError(JSON.parse(request.responseText).message));\n    };\n\n    request.send();\n  };\n}\n/*\n * Build query used to fetch directions\n *\n * @param {Function} state\n */\n\n\nfunction buildDirectionsQuery(state) {\n  const {\n    origin,\n    destination,\n    waypoints\n  } = state();\n  let query = [];\n  query.push(origin.geometry.coordinates.join(','));\n  query.push(';'); // Add any waypoints.\n\n  if (waypoints.length) {\n    waypoints.forEach(waypoint => {\n      query.push(waypoint.geometry.coordinates.join(','));\n      query.push(';');\n    });\n  }\n\n  query.push(destination.geometry.coordinates.join(','));\n  return encodeURIComponent(query.join(''));\n}\n\nfunction normalizeWaypoint(waypoint) {\n  const properties = {\n    id: 'waypoint'\n  };\n  return Object.assign(waypoint, {\n    properties: waypoint.properties ? Object.assign(waypoint.properties, properties) : properties\n  });\n}\n\nfunction setError(error) {\n  return dispatch => {\n    dispatch({\n      type: 'ERROR',\n      error\n    });\n    if (error) dispatch(eventEmit('error', {\n      error: error\n    }));\n  };\n}\n\nexport function queryOrigin(query) {\n  return {\n    type: types.ORIGIN_QUERY,\n    query\n  };\n}\nexport function queryDestination(query) {\n  return {\n    type: types.DESTINATION_QUERY,\n    query\n  };\n}\nexport function queryOriginCoordinates(coords) {\n  return {\n    type: types.ORIGIN_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\nexport function queryDestinationCoordinates(coords) {\n  return {\n    type: types.DESTINATION_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\nexport function clearOrigin() {\n  return dispatch => {\n    dispatch({\n      type: types.ORIGIN_CLEAR\n    });\n    dispatch(eventEmit('clear', {\n      type: 'origin'\n    }));\n    dispatch(setError(null));\n  };\n}\nexport function clearDestination() {\n  return dispatch => {\n    dispatch({\n      type: types.DESTINATION_CLEAR\n    });\n    dispatch(eventEmit('clear', {\n      type: 'destination'\n    }));\n    dispatch(setError(null));\n  };\n}\nexport function setOptions(options) {\n  return {\n    type: types.SET_OPTIONS,\n    options: options\n  };\n}\nexport function hoverMarker(coordinates) {\n  return dispatch => {\n    const feature = coordinates ? utils.createPoint(coordinates, {\n      id: 'hover'\n    }) : {};\n    dispatch(setHoverMarker(feature));\n  };\n}\nexport function setRouteIndex(routeIndex) {\n  return {\n    type: types.ROUTE_INDEX,\n    routeIndex\n  };\n}\nexport function createOrigin(coordinates) {\n  return (dispatch, getState) => {\n    const {\n      destination\n    } = getState();\n    dispatch(originPoint(coordinates));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function createDestination(coordinates) {\n  return (dispatch, getState) => {\n    const {\n      origin\n    } = getState();\n    dispatch(destinationPoint(coordinates));\n    if (origin.geometry) dispatch(fetchDirections());\n  };\n}\nexport function setProfile(profile) {\n  return (dispatch, getState) => {\n    const {\n      origin,\n      destination\n    } = getState();\n    dispatch({\n      type: types.DIRECTIONS_PROFILE,\n      profile\n    });\n    dispatch(eventEmit('profile', {\n      profile\n    }));\n    if (origin.geometry && destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function reverse() {\n  return (dispatch, getState) => {\n    const state = getState();\n    if (state.destination.geometry) dispatch(originPoint(state.destination.geometry.coordinates));\n    if (state.origin.geometry) dispatch(destinationPoint(state.origin.geometry.coordinates));\n    if (state.origin.geometry && state.destination.geometry) dispatch(fetchDirections());\n    const suggestions = document.getElementsByClassName('suggestions');\n\n    for (var i = 0; i < suggestions.length; i++) {\n      suggestions[i].style.visibility = 'hidden';\n    }\n\n    ;\n  };\n}\n/*\n * Set origin from coordinates\n *\n * @param {Array<number>} coordinates [lng, lat] array.\n */\n\nexport function setOriginFromCoordinates(coords) {\n  return dispatch => {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(queryOriginCoordinates(coords));\n    dispatch(createOrigin(coords));\n  };\n}\n/*\n * Set destination from coordinates\n *\n * @param {Array<number>} coords [lng, lat] array.\n */\n\nexport function setDestinationFromCoordinates(coords) {\n  return dispatch => {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(createDestination(coords));\n    dispatch(queryDestinationCoordinates(coords));\n  };\n}\nexport function addWaypoint(index, waypoint) {\n  return (dispatch, getState) => {\n    let {\n      destination,\n      waypoints\n    } = getState();\n    waypoints.splice(index, 0, normalizeWaypoint(waypoint));\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function setWaypoint(index, waypoint) {\n  return (dispatch, getState) => {\n    let {\n      destination,\n      waypoints\n    } = getState();\n    waypoints[index] = normalizeWaypoint(waypoint);\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function removeWaypoint(waypoint) {\n  return (dispatch, getState) => {\n    let {\n      destination,\n      waypoints\n    } = getState();\n    waypoints = waypoints.filter(way => {\n      return !utils.coordinateMatch(way, waypoint);\n    });\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\nexport function eventSubscribe(type, fn) {\n  return (dispatch, getState) => {\n    const {\n      events\n    } = getState();\n    events[type] = events[type] || [];\n    events[type].push(fn);\n    return {\n      type: types.EVENTS,\n      events\n    };\n  };\n}\nexport function eventEmit(type, data) {\n  return (dispatch, getState) => {\n    const {\n      events\n    } = getState();\n\n    if (!events[type]) {\n      return {\n        type: types.EVENTS,\n        events\n      };\n    }\n\n    const listeners = events[type].slice();\n\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i].call(this, data);\n    }\n  };\n}","map":{"version":3,"names":["types","utils","request","XMLHttpRequest","originPoint","coordinates","dispatch","origin","createPoint","id","type","ORIGIN","eventEmit","feature","destinationPoint","destination","DESTINATION","setDirections","directions","DIRECTIONS","route","updateWaypoints","waypoints","WAYPOINTS","setHoverMarker","HOVER_MARKER","hoverMarker","fetchDirections","getState","api","accessToken","routeIndex","profile","alternatives","congestion","language","exclude","geometry","query","buildDirectionsQuery","options","push","abort","open","join","onload","status","data","JSON","parse","responseText","error","setError","routes","setRouteIndex","location","length","message","onerror","send","state","forEach","waypoint","encodeURIComponent","normalizeWaypoint","properties","Object","assign","queryOrigin","ORIGIN_QUERY","queryDestination","DESTINATION_QUERY","queryOriginCoordinates","coords","ORIGIN_FROM_COORDINATES","queryDestinationCoordinates","DESTINATION_FROM_COORDINATES","clearOrigin","ORIGIN_CLEAR","clearDestination","DESTINATION_CLEAR","setOptions","SET_OPTIONS","ROUTE_INDEX","createOrigin","createDestination","setProfile","DIRECTIONS_PROFILE","reverse","suggestions","document","getElementsByClassName","i","style","visibility","setOriginFromCoordinates","validCoords","wrap","isNaN","Error","setDestinationFromCoordinates","addWaypoint","index","splice","setWaypoint","removeWaypoint","filter","way","coordinateMatch","eventSubscribe","fn","events","EVENTS","listeners","slice","call"],"sources":["C:/Users/Surface-Pro/React/mapbox_test/node_modules/@mapbox/mapbox-gl-directions/src/actions/index.js"],"sourcesContent":["import * as types from '../constants/action_types';\nimport utils from '../utils';\nconst request = new XMLHttpRequest();\n\nfunction originPoint(coordinates) {\n  return (dispatch) => {\n    const origin = utils.createPoint(coordinates, {\n      id: 'origin',\n      'marker-symbol': 'A'\n    });\n\n    dispatch({ type: types.ORIGIN, origin });\n    dispatch(eventEmit('origin', { feature: origin }));\n  };\n}\n\nfunction destinationPoint(coordinates) {\n  return (dispatch) => {\n    const destination = utils.createPoint(coordinates, {\n      id: 'destination',\n      'marker-symbol': 'B'\n    });\n\n    dispatch({ type: types.DESTINATION, destination });\n    dispatch(eventEmit('destination', { feature: destination }));\n  };\n}\n\nfunction setDirections(directions) {\n  return dispatch => {\n    dispatch({\n      type: types.DIRECTIONS,\n      directions\n    });\n    dispatch(eventEmit('route', { route: directions }));\n  };\n}\n\nfunction updateWaypoints(waypoints) {\n  return {\n    type: types.WAYPOINTS,\n    waypoints: waypoints\n  };\n}\n\nfunction setHoverMarker(feature) {\n  return {\n    type: types.HOVER_MARKER,\n    hoverMarker: feature\n  };\n}\n\nfunction fetchDirections() {\n  return (dispatch, getState) => {\n    const { api, accessToken, routeIndex, profile, alternatives, congestion, destination, language, exclude } = getState();\n    // if there is no destination set, do not make request because it will fail\n    if (!(destination && destination.geometry)) return;\n\n    const query = buildDirectionsQuery(getState);\n\n    // Request params\n    var options = [];\n    options.push('geometries=polyline');\n    if (alternatives) options.push('alternatives=true');\n    if (congestion) options.push('annotations=congestion');\n    options.push('steps=true');\n    options.push('overview=full');\n    if (language) options.push('language='+language);\n    if (exclude) options.push('exclude=' + exclude);\n    if (accessToken) options.push('access_token=' + accessToken);\n    request.abort();\n    request.open('GET', `${api}${profile}/${query}.json?${options.join('&')}`, true);\n\n    request.onload = () => {\n      if (request.status >= 200 && request.status < 400) {\n        var data = JSON.parse(request.responseText);\n        if (data.error) {\n          dispatch(setDirections([]));\n          return dispatch(setError(data.error));\n        }\n\n        dispatch(setError(null));\n        if (!data.routes[routeIndex]) dispatch(setRouteIndex(0));\n        dispatch(setDirections(data.routes));\n\n        // Revise origin / destination points\n        dispatch(originPoint(data.waypoints[0].location));\n        dispatch(destinationPoint(data.waypoints[data.waypoints.length - 1].location));\n      } else {\n        dispatch(setDirections([]));\n        return dispatch(setError(JSON.parse(request.responseText).message));\n      }\n    };\n\n    request.onerror = () => {\n      dispatch(setDirections([]));\n      return dispatch(setError(JSON.parse(request.responseText).message));\n    };\n\n    request.send();\n  };\n}\n\n/*\n * Build query used to fetch directions\n *\n * @param {Function} state\n */\nfunction buildDirectionsQuery(state) {\n  const { origin, destination, waypoints } = state();\n\n  let query = [];\n  query.push((origin.geometry.coordinates).join(','));\n  query.push(';');\n\n  // Add any waypoints.\n  if (waypoints.length) {\n    waypoints.forEach((waypoint) => {\n      query.push((waypoint.geometry.coordinates).join(','));\n      query.push(';');\n    });\n  }\n\n  query.push((destination.geometry.coordinates).join(','));\n  return encodeURIComponent(query.join(''));\n}\n\nfunction normalizeWaypoint(waypoint) {\n  const properties = { id: 'waypoint' };\n  return Object.assign(waypoint, {\n    properties: waypoint.properties ?\n      Object.assign(waypoint.properties, properties) :\n      properties\n  });\n}\n\nfunction setError(error) {\n  return dispatch => {\n    dispatch({\n      type: 'ERROR',\n      error\n    });\n    if (error) dispatch(eventEmit('error', { error: error }));\n  };\n}\n\nexport function queryOrigin(query) {\n  return {\n    type: types.ORIGIN_QUERY,\n    query\n  };\n}\n\nexport function queryDestination(query) {\n  return {\n    type: types.DESTINATION_QUERY,\n    query\n  };\n}\n\nexport function queryOriginCoordinates(coords) {\n  return {\n    type: types.ORIGIN_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\n\nexport function queryDestinationCoordinates(coords) {\n  return {\n    type: types.DESTINATION_FROM_COORDINATES,\n    coordinates: coords\n  };\n}\n\nexport function clearOrigin() {\n  return dispatch => {\n    dispatch({\n      type: types.ORIGIN_CLEAR\n    });\n    dispatch(eventEmit('clear', { type: 'origin' }));\n    dispatch(setError(null));\n  };\n}\n\nexport function clearDestination() {\n  return dispatch => {\n    dispatch({\n      type: types.DESTINATION_CLEAR\n    });\n    dispatch(eventEmit('clear', { type: 'destination' }));\n    dispatch(setError(null));\n  };\n}\n\nexport function setOptions(options) {\n  return {\n    type: types.SET_OPTIONS,\n    options: options\n  };\n}\n\nexport function hoverMarker(coordinates) {\n  return (dispatch) => {\n    const feature = (coordinates) ? utils.createPoint(coordinates, { id: 'hover'}) : {};\n    dispatch(setHoverMarker(feature));\n  };\n}\n\nexport function setRouteIndex(routeIndex) {\n  return {\n    type: types.ROUTE_INDEX,\n    routeIndex\n  };\n}\n\nexport function createOrigin(coordinates) {\n  return (dispatch, getState) => {\n    const { destination } = getState();\n    dispatch(originPoint(coordinates));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function createDestination(coordinates) {\n  return (dispatch, getState) => {\n    const { origin } = getState();\n    dispatch(destinationPoint(coordinates));\n    if (origin.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function setProfile(profile) {\n  return (dispatch, getState) => {\n    const { origin, destination } = getState();\n    dispatch({ type: types.DIRECTIONS_PROFILE, profile });\n    dispatch(eventEmit('profile', { profile }));\n    if (origin.geometry && destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function reverse() {\n  return (dispatch, getState) => {\n    const state = getState();\n    if (state.destination.geometry) dispatch(originPoint(state.destination.geometry.coordinates));\n    if (state.origin.geometry) dispatch(destinationPoint(state.origin.geometry.coordinates));\n    if (state.origin.geometry && state.destination.geometry) dispatch(fetchDirections());\n    const suggestions = document.getElementsByClassName('suggestions');\n    for (var i = 0; i < suggestions.length; i++) {\n      suggestions[i].style.visibility = 'hidden';\n    };\n  };\n}\n\n/*\n * Set origin from coordinates\n *\n * @param {Array<number>} coordinates [lng, lat] array.\n */\nexport function setOriginFromCoordinates(coords) {\n  return (dispatch) => {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(queryOriginCoordinates(coords));\n    dispatch(createOrigin(coords));\n  };\n}\n\n/*\n * Set destination from coordinates\n *\n * @param {Array<number>} coords [lng, lat] array.\n */\nexport function setDestinationFromCoordinates(coords) {\n  return (dispatch) => {\n    if (!utils.validCoords(coords)) coords = [utils.wrap(coords[0]), utils.wrap(coords[1])];\n    if (isNaN(coords[0]) && isNaN(coords[1])) return dispatch(setError(new Error('Coordinates are not valid')));\n    dispatch(createDestination(coords));\n    dispatch(queryDestinationCoordinates(coords));\n  };\n}\n\nexport function addWaypoint(index, waypoint) {\n  return (dispatch, getState) => {\n    let { destination, waypoints } = getState();\n    waypoints.splice(index, 0, normalizeWaypoint(waypoint));\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function setWaypoint(index, waypoint) {\n  return (dispatch, getState) => {\n    let { destination, waypoints } = getState();\n    waypoints[index] = normalizeWaypoint(waypoint);\n    dispatch(updateWaypoints(waypoints));\n    if (destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function removeWaypoint(waypoint) {\n  return (dispatch, getState) => {\n    let { destination, waypoints } = getState();\n      waypoints = waypoints.filter((way) => {\n        return !utils.coordinateMatch(way, waypoint);\n      });\n\n      dispatch(updateWaypoints(waypoints));\n      if (destination.geometry) dispatch(fetchDirections());\n  };\n}\n\nexport function eventSubscribe(type, fn) {\n  return (dispatch, getState) => {\n    const { events } = getState();\n    events[type] = events[type] || [];\n    events[type].push(fn);\n    return {\n      type: types.EVENTS,\n      events\n    };\n  };\n}\n\nexport function eventEmit(type, data) {\n  return (dispatch, getState) => {\n    const { events } = getState();\n\n    if (!events[type]) {\n      return {\n        type: types.EVENTS,\n        events\n      };\n    }\n\n    const listeners = events[type].slice();\n\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i].call(this, data);\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}