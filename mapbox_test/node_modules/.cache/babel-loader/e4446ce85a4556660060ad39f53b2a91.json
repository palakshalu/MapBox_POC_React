{"ast":null,"code":"/**\n * Lazily iterate over coordinates in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var point = { type: 'Point', coordinates: [0, 0] };\n * coordEach(point, function(coords) {\n *   // coords is equal to [0, 0]\n * });\n */\nfunction coordEach(layer, callback, excludeWrapCoord) {\n  var i,\n      j,\n      k,\n      g,\n      geometry,\n      stopG,\n      coords,\n      geometryMaybeCollection,\n      wrapShrink = 0,\n      isGeometryCollection,\n      isFeatureCollection = layer.type === 'FeatureCollection',\n      isFeature = layer.type === 'Feature',\n      stop = isFeatureCollection ? layer.features.length : 1; // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? layer.features[i].geometry : isFeature ? layer.geometry : layer;\n    isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      coords = geometry.coordinates;\n      wrapShrink = excludeWrapCoord && (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') ? 1 : 0;\n\n      if (geometry.type === 'Point') {\n        callback(coords);\n      } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {\n        for (j = 0; j < coords.length; j++) callback(coords[j]);\n      } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {\n        for (j = 0; j < coords.length; j++) for (k = 0; k < coords[j].length - wrapShrink; k++) callback(coords[j][k]);\n      } else if (geometry.type === 'MultiPolygon') {\n        for (j = 0; j < coords.length; j++) for (k = 0; k < coords[j].length; k++) for (l = 0; l < coords[j][k].length - wrapShrink; l++) callback(coords[j][k][l]);\n      } else {\n        throw new Error('Unknown Geometry Type');\n      }\n    }\n  }\n}\n\nmodule.exports.coordEach = coordEach;\n/**\n * Lazily reduce coordinates in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all coordinates is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, value) and returns\n * a new memo\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @param {*} memo the starting value of memo: can be any type.\n */\n\nfunction coordReduce(layer, callback, memo, excludeWrapCoord) {\n  coordEach(layer, function (coord) {\n    memo = callback(memo, coord);\n  }, excludeWrapCoord);\n  return memo;\n}\n\nmodule.exports.coordReduce = coordReduce;\n/**\n * Lazily iterate over property objects in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @example\n * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };\n * propEach(point, function(props) {\n *   // props is equal to { foo: 1}\n * });\n */\n\nfunction propEach(layer, callback) {\n  var i;\n\n  switch (layer.type) {\n    case 'FeatureCollection':\n      features = layer.features;\n\n      for (i = 0; i < layer.features.length; i++) {\n        callback(layer.features[i].properties);\n      }\n\n      break;\n\n    case 'Feature':\n      callback(layer.properties);\n      break;\n  }\n}\n\nmodule.exports.propEach = propEach;\n/**\n * Lazily reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, coord) and returns\n * a new memo\n * @param {*} memo the starting value of memo: can be any type.\n */\n\nfunction propReduce(layer, callback, memo) {\n  propEach(layer, function (prop) {\n    memo = callback(memo, prop);\n  });\n  return memo;\n}\n\nmodule.exports.propReduce = propReduce;","map":{"version":3,"names":["coordEach","layer","callback","excludeWrapCoord","i","j","k","g","geometry","stopG","coords","geometryMaybeCollection","wrapShrink","isGeometryCollection","isFeatureCollection","type","isFeature","stop","features","length","geometries","coordinates","l","Error","module","exports","coordReduce","memo","coord","propEach","properties","propReduce","prop"],"sources":["C:/Users/Surface-Pro/React/mapbox_test/node_modules/turf-meta/index.js"],"sourcesContent":["/**\n * Lazily iterate over coordinates in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var point = { type: 'Point', coordinates: [0, 0] };\n * coordEach(point, function(coords) {\n *   // coords is equal to [0, 0]\n * });\n */\nfunction coordEach(layer, callback, excludeWrapCoord) {\n  var i, j, k, g, geometry, stopG, coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    isGeometryCollection,\n    isFeatureCollection = layer.type === 'FeatureCollection',\n    isFeature = layer.type === 'Feature',\n    stop = isFeatureCollection ? layer.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n\n    geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :\n        (isFeature ? layer.geometry : layer));\n    isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (g = 0; g < stopG; g++) {\n\n      geometry = isGeometryCollection ?\n          geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      coords = geometry.coordinates;\n\n      wrapShrink = (excludeWrapCoord &&\n        (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?\n        1 : 0;\n\n      if (geometry.type === 'Point') {\n        callback(coords);\n      } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {\n        for (j = 0; j < coords.length; j++) callback(coords[j]);\n      } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {\n        for (j = 0; j < coords.length; j++)\n          for (k = 0; k < coords[j].length - wrapShrink; k++)\n            callback(coords[j][k]);\n      } else if (geometry.type === 'MultiPolygon') {\n        for (j = 0; j < coords.length; j++)\n          for (k = 0; k < coords[j].length; k++)\n            for (l = 0; l < coords[j][k].length - wrapShrink; l++)\n              callback(coords[j][k][l]);\n      } else {\n        throw new Error('Unknown Geometry Type');\n      }\n    }\n  }\n}\nmodule.exports.coordEach = coordEach;\n\n/**\n * Lazily reduce coordinates in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all coordinates is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, value) and returns\n * a new memo\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @param {*} memo the starting value of memo: can be any type.\n */\nfunction coordReduce(layer, callback, memo, excludeWrapCoord) {\n  coordEach(layer, function(coord) {\n    memo = callback(memo, coord);\n  }, excludeWrapCoord);\n  return memo;\n}\nmodule.exports.coordReduce = coordReduce;\n\n/**\n * Lazily iterate over property objects in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @example\n * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };\n * propEach(point, function(props) {\n *   // props is equal to { foo: 1}\n * });\n */\nfunction propEach(layer, callback) {\n  var i;\n  switch (layer.type) {\n      case 'FeatureCollection':\n        features = layer.features;\n        for (i = 0; i < layer.features.length; i++) {\n            callback(layer.features[i].properties);\n        }\n        break;\n      case 'Feature':\n        callback(layer.properties);\n        break;\n  }\n}\nmodule.exports.propEach = propEach;\n\n/**\n * Lazily reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, coord) and returns\n * a new memo\n * @param {*} memo the starting value of memo: can be any type.\n */\nfunction propReduce(layer, callback, memo) {\n  propEach(layer, function(prop) {\n    memo = callback(memo, prop);\n  });\n  return memo;\n}\nmodule.exports.propReduce = propReduce;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}